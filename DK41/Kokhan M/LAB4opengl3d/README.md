# Лабораторна робота: Двовимірна графіка засобами OpenGL з залученням списків

## Опис програми

**Варіант №:** 7

**Обрана фігура:** Трикутник.

Ця програма демонструє основи роботи з 2D-графікою в OpenGL та використання двозв'язного списку для керування об'єктами на сцені.

**Основний функціонал:**
1.  Створюється вікно за допомогою бібліотеки GLUT.
2.  На сцені відображається набір двовимірних фігур (трикутників).
3.  Всі фігури синхронно обертаються навколо центру координат (0,0).
4.  Програма демонструє роботу зі списком фігур:
    *   **Створення:** Створюється початковий список з трьох трикутників.
    *   **Видалення:** Зі списку видаляється елемент за індексом (у прикладі видаляється другий трикутник).
    *   **Вставка:** На місце видаленого елемента вставляється нова фігура (новий синій трикутник).

Консольний вивід програми ілюструє кроки маніпуляції зі списком.

## Контрольні запитання

**1. Які функції для роботи безпосередньо з OpenGL ви імплементували? Коротко опишіть їхнє призначення.**

У цій роботі були використані наступні функції OpenGL:

*   `glClearColor()`: Встановлює колір, яким буде очищуватися екран.
*   `glClear()`: Очищує буфери (у нашому випадку `GL_COLOR_BUFFER_BIT` — буфер кольору).
*   `glBegin(GL_TRIANGLES)` / `glEnd()`: Визначають початок та кінець блоку для малювання примітивів (трикутників).
*   `glColor3f()`: Встановлює поточний колір для малювання (3 float-значення для R, G, B).
*   `glVertex2f()`: Задає координати вершини примітиву у 2D-просторі.
*   `glPushMatrix()` / `glPopMatrix()`: Зберігають та відновлюють поточну матрицю трансформацій. Це дозволяє застосувати трансформацію (обертання) лише до певних об'єктів і потім повернутися до попереднього стану.
*   `glRotatef()`: Застосовує трансформацію обертання до поточної матриці.
*   `glutSwapBuffers()`: У режимі подвійної буферизації міняє місцями передній та задній буфери, що робить анімацію плавною та усуває мерехтіння.

**2. Яке призначення двозв’язного списку в цій лабораторній роботі? Імплементація якої функції роботи зі складовими списку дозволяє «поєднати» функціонал двозв’язного списку з OpenGL?**

Призначення двозв'язного списку — зберігати динамічну колекцію графічних об'єктів (фігур). Це дозволяє легко додавати, видаляти та змінювати фігури на сцені під час виконання програми, не перекомпільовуючи її.

Функція, яка "поєднує" список з OpenGL — це `drawFigList()`. Вона ітерує по всіх елементах списку (від `head` до `tail`) і для кожної фігури викликає функцію `drawFigure()`. У свою чергу, `drawFigure()` використовує функції OpenGL (`glBegin`, `glColor3f`, `glVertex2f` та ін.) для безпосереднього відтворення фігури на екрані. Таким чином, `drawFigList` транслює структуру даних (список) у графічне представлення засобами OpenGL.

**3. За допомогою якого функціоналу OpenGL (очікування, обробка подій від таймера) у Вашій роботі реалізовано анімацію обертання?**

Анімація обертання реалізована за допомогою обробки подій від таймера. Для цього використовується функція GLUT `glutTimerFunc(delay, callback_func, value)`.

*   У функції `main` ми робимо початковий виклик `glutTimerFunc(0, timer, 0)`.
*   Це реєструє функцію `timer` як функцію зворотного виклику, яка виконається через заданий інтервал часу (`timer_interval`).
*   Усередині функції `timer` ми оновлюємо глобальну змінну кута обертання (`theta`), даємо команду на перемальовку вікна (`glutPostRedisplay()`) і, що найважливіше, рекурсивно реєструємо новий виклик самої себе.
*   Цей ланцюжок викликів створює безперервну анімацію з фіксованою частотою кадрів.

**4. Якими функціями OpenGL і як саме Ви користувались для безпосередньо обертання фігур?**

Для обертання фігур використовувалася функція `glRotatef(angle, x, y, z)`.

*   `angle` — кут обертання в градусах.
*   `(x, y, z)` — вектор, навколо якого відбувається обертання.

У моїй програмі виклик виглядає так: `glRotatef(theta, 0.0f, 0.0f, 1.0f)`. Це означає, що всі наступні команди малювання будуть виконуватися в системі координат, поверненій на `theta` градусів навколо осі Z. Оскільки ми працюємо у 2D, вісь Z "дивиться" на нас із екрана, і обертання навколо неї призводить до обертання фігур на площині.

Для ізоляції цієї трансформації, щоб вона не впливала на інші елементи (якщо вони є), виклик `glRotatef` обгорнутий у `glPushMatrix()` та `glPopMatrix()`.

**5. Які існують команди роботи з матрицями трансформації в OpenGL?**

Основні команди для роботи з матрицями трансформацій у застарілому (fixed-function) OpenGL:

*   `glMatrixMode(mode)`: Вибирає поточну матрицю для операцій (`GL_MODELVIEW`, `GL_PROJECTION`, `GL_TEXTURE`).
*   `glLoadIdentity()`: Замінює поточну матрицю на одиничну (скидає всі трансформації).
*   `glTranslate{f,d}(x, y, z)`: Трансформація переміщення.
*   `glRotate{f,d}(angle, x, y, z)`: Трансформація обертання.
*   `glScale{f,d}(x, y, z)`: Трансформація масштабування.
*   `glMultMatrix{f,d}(*m)`: Множить поточну матрицю на задану матрицю `m`.
*   `glPushMatrix()`: Зберігає копію поточної матриці у стеку.
*   `glPopMatrix()`: Виштовхує матрицю з вершини стека, відновлюючи попередній стан.

**6. Які функції реєстрації зворотних викликів OpenGL зазвичай використовуються для анімацій?**

Для анімацій зазвичай використовуються дві функції реєстрації зворотних викликів:

1.  `glutTimerFunc(delay, callback, value)`: Реєструє функцію, яка буде викликана один раз через `delay` мілісекунд. Це найкращий підхід для створення анімації з контрольованою та стабільною частотою кадрів. Для безперервної анімації функція зворотного виклику повинна сама реєструвати свій наступний виклик.
2.  `glutIdleFunc(callback)`: Реєструє функцію, яка викликається, коли програма "простоює" (немає інших подій для обробки). Це призводить до максимально можливої частоти кадрів, але ця частота не є стабільною і залежить від потужності комп'ютера та складності сцени. Це може призводити до зайвого навантаження на процесор.

У даній роботі використано `glutTimerFunc`, оскільки він забезпечує більш передбачувану та плавну анімацію.
