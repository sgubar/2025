# Варіант №4 – Призма з основою правильного трикутника

## Опис завдання

У цій лабораторній роботі реалізовано об’ємну 3D фігуру – **призму з основою правильного трикутника**, центр якої розташовано в точці **(0, 0, 0)**.

Фігура автоматично **обертається навколо осі Oy** (анімовано), а кожна грань має **власний колір**, що візуально виділяє структуру об'єкта.

Програма написана з використанням **OpenGL + GLUT** у програмі **CodeBlocks**.


## Контрольні питання

### 1. Які функції для роботи безпосередньо з OpenGL ви імплементували?

- **`glBegin(), glEnd()`**
ці функції визначають блок малювання. Всередині між ними я вказував, які геометричні примітиви малювати: GL_TRIANGLES для основ призми (трикутники), GL_QUADS для бокових граней (чотирикутники).
- **`glVertex3f(x, y, z)`**
задає координати кожної вершини в 3D-просторі. Я використовував цю функцію, щоб побудувати вершини трикутної призми з основою в центрі координат (0, 0, 0).
- **`glColor3f(r, g, b)`**
ця функція дозволяє встановити колір поточної грані. Я використав її для того, щоб зробити кожну грань різнокольоровою.
- **`glClear()`**
очищає буфери зображення і глибини перед кожним новим кадром. Це потрібно, щоб не було накладення старих об’єктів на нові.
- **`glLoadIdentity()`**
скидає поточну матрицю трансформацій, щоб кожного разу починати з "чистого аркуша" при побудові об'єкта.
- **`glRotatef(angle, x, y, z)`**
обертає об’єкт навколо вказаної осі. У моєму випадку: обертання навколо осі Oy (0, 1, 0), щоб створити анімацію.
- **`glTranslatef()`**
зміщує об’єкт у сцені. Я використав це, щоб змістити призму назад по осі Z для кращого огляду.
- **`glEnable(GL_DEPTH_TEST)`**
вмикає перевірку глибини, що дозволяє коректно відображати об’єкти, які перекривають один одного.
- **`gluPerspective(fov, aspect, zNear, zFar)`**
задає перспективну проекцію, щоб сцена виглядала реалістично (з врахуванням перспективи).
```


### 2. Які функції реєстрації зворотних викликів ви використовували?

glutDisplayFunc(display);   // функція прив’язує головну функцію візуалізації сцени, викликається кожного разу, коли потрібно перемалювати вікно. Всередині display() я малюю призму.
glutReshapeFunc(reshape);   // у ній я налаштовую проекційну матрицю та співвідношення сторін, щоб зображення не спотворювалось.
glutKeyboardFunc(keyboard); // дозволяє обробляти натискання клавіш. у мене використовується для виходу з програми при натисканні Esc.
glutTimerFunc(...);         // запускає таймер для створення анімації. Я використовую таймер для періодичного оновлення кута обертання та перемалювання сцени.
```


### 3. Які існують інші функції обробки подій? Коротко опишіть їхнє призначення.
# Окрім вищезгаданих, у GLUT є багато функцій для обробки різних типів подій. Ось декілька прикладів, які я можу використати (або використав у схожих проєктах):

- `glutMouseFunc()` – натискання кнопок миші (можна використати для інтерфейсу або обертання).
- `glutMotionFunc()` – рух миші при натиснутій кнопці (керування камерою або об'єктом).
- `glutSpecialFunc()` – обробка спеціальних клавіш (стрілки, F1–F12). Це може бути використано, наприклад, для обертання або зміни положення об'єкта.

