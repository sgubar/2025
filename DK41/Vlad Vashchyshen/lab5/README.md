# Варіант №4 – Призма з основою правильного трикутника

## Опис завдання

У цій лабораторній роботі реалізовано об’ємну 3D фігуру – **призму з основою правильного трикутника**, центр якої розташовано в точці **(0, 0, 0)**.

Фігура автоматично **обертається навколо осі Oy** (анімовано), а кожна грань має **власний колір**, що візуально виділяє структуру об'єкта.

Програма написана з використанням **OpenGL + GLUT** у середовищі **Code::Blocks**.


## Контрольні питання

### 1. Які функції для роботи безпосередньо з OpenGL ви імплементували?

- **`glBegin(), glEnd()`**
ці функції визначають блок малювання. Всередині між ними я вказував, які геометричні примітиви малювати: GL_TRIANGLES для основ призми (трикутники), GL_QUADS для бокових граней (чотирикутники).
- **`glVertex3f(x, y, z)`**
задає координати кожної вершини в 3D-просторі. Я використовував цю функцію, щоб побудувати вершини трикутної призми з основою в центрі координат (0, 0, 0).
- **`glColor3f(r, g, b)`**
ця функція дозволяє встановити колір поточної грані. Я використав її для того, щоб зробити кожну грань різнокольоровою.
- **`glClear()`**
очищає буфери зображення і глибини перед кожним новим кадром. Це потрібно, щоб не було накладення старих об’єктів на нові.
- **`glLoadIdentity()`**
скидає поточну матрицю трансформацій, щоб кожного разу починати з "чистого аркуша" при побудові об'єкта.
- **`glRotatef(angle, x, y, z)`**
обертає об’єкт навколо вказаної осі. У моєму випадку: обертання навколо осі Oy (0, 1, 0), щоб створити анімацію.
- **`glTranslatef()`**
зміщує об’єкт у сцені. Я використав це, щоб змістити призму назад по осі Z для кращого огляду.
- **`glEnable(GL_DEPTH_TEST)`**
вмикає перевірку глибини, що дозволяє коректно відображати об’єкти, які перекривають один одного.
- **`gluPerspective(fov, aspect, zNear, zFar)`**
задає перспективну проекцію, щоб сцена виглядала реалістично (з врахуванням перспективи).
```

Ці функції дозволили побудувати об’єкт у 3D-просторі, задавати його вигляд, кольори та забезпечити коректне візуальне відображення.

---

### 2. Які функції реєстрації зворотних викликів ви використовували?

```cpp
glutDisplayFunc(display);   // Малювання сцени
glutReshapeFunc(reshape);   // Реакція на зміну розміру вікна
glutKeyboardFunc(keyboard); // Клавіатурний ввід (Esc)
glutTimerFunc(...);         // Анімація (таймер обертання)
```

Ці функції дозволили програмі реагувати на зовнішні події: перерисовку, зміну розміру, натискання клавіш та керувати анімацією фігури.

---

### 3. Які існують інші функції обробки подій? Коротко опишіть їхнє призначення.

- `glutMouseFunc()` – натискання кнопок миші (можна використати для інтерфейсу або обертання).
- `glutMotionFunc()` – рух миші при натиснутій кнопці (керування камерою або об'єктом).
- `glutSpecialFunc()` – обробка спеціальних клавіш (стрілки, F1–F12).
- `glutIdleFunc()` – безперервна обробка, коли програма «вільна» (альтернатива таймеру).
